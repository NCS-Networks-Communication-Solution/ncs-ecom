# NCS B2B E-Commerce Platform - Day 4 Execution Plan

**Date:** Sunday, September 29, 2025  
**Location:** Bangkok, Thailand  
**Current Sprint:** Week 1 - Business Logic Implementation Phase

## Executive Summary

Day 4 marks the transition from infrastructure setup to core business logic implementation. With the Prisma blocker resolved and NestJS structure in place, today focuses on implementing authentication (JWT), expanding the database schema for products and orders, creating essential API endpoints, and seeding initial data. This aligns with catching up on the postponed tasks from the original Day 8-9 schedule while maintaining momentum toward the January 11, 2026 launch.

## Current Project Status

**Completed (Days 0-3):**

- ✅ Docker Compose infrastructure (PostgreSQL + Redis healthy)
- ✅ Prisma ORM integrated with initial User/Company/Role schema
- ✅ NestJS backend scaffolded with working health endpoints
- ✅ Next.js frontend running on localhost:3000
- ✅ CI/CD pipeline passing all checks
- ✅ Environment configuration templates established

**Today's Focus:** Transform the scaffolded backend into a functional API with authentication and product catalog capabilities.

---

## Day 4 Schedule (09:00-18:00 BKK)

### 09:00-10:30: Authentication Module Implementation

### 10:30-12:00: Expand Database Schema (Products, Orders, RFQ)

### 13:00-14:30: Product Catalog API Endpoints

### 14:30-16:00: Database Seeding & Initial Data

### 16:00-17:00: Integration Testing

### 17:00-18:00: Documentation & Commit

---

## Detailed Implementation Steps

### Step 1: Authentication Module (09:00-10:30)

#### 1.1 Install JWT Dependencies

```bash
cd ~/Desktop/Project_Hiroshima/ncs-ecom/backend
npm install @nestjs/jwt @nestjs/passport passport passport-jwt bcryptjs
npm install --save-dev @types/passport-jwt @types/bcryptjs
```

#### 1.2 Create Auth Module Structure

```bash
nest g module auth
nest g controller auth
nest g service auth
nest g module users
nest g service users
```

#### 1.3 Implement JWT Strategy

```typescript
// src/auth/jwt.strategy.ts
cat > src/auth/jwt.strategy.ts << 'EOF'
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET || 'ncs-jwt-secret-dev-2025',
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, email: payload.email, role: payload.role };
  }
}
EOF
```

#### 1.4 Create Auth Service with Login/Register

```typescript
// src/auth/auth.service.ts
cat > src/auth/auth.service.ts << 'EOF'
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../prisma.service';
import * as bcrypt from 'bcryptjs';

@Injectable()
export class AuthService {
  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService
  ) {}

  async register(email: string, password: string, name: string, companyId: string) {
    const hashedPassword = await bcrypt.hash(password, 10);
    
    const user = await this.prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        name,
        companyId,
        role: 'USER',
      },
      include: { company: true },
    });

    return this.generateTokens(user);
  }

  async login(email: string, password: string) {
    const user = await this.prisma.user.findUnique({
      where: { email },
      include: { company: true },
    });

    if (!user || !(await bcrypt.compare(password, user.password))) {
      throw new UnauthorizedException('Invalid credentials');
    }

    return this.generateTokens(user);
  }

  private generateTokens(user: any) {
    const payload = {
      sub: user.id,
      email: user.email,
      role: user.role,
      companyId: user.companyId,
    };

    return {
      access_token: this.jwtService.sign(payload),
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        role: user.role,
        company: user.company.name,
      },
    };
  }
}
EOF
```

#### 1.5 Create Auth Controller

```typescript
// src/auth/auth.controller.ts
cat > src/auth/auth.controller.ts << 'EOF'
import { Controller, Post, Body, HttpCode, HttpStatus } from '@nestjs/common';
import { AuthService } from './auth.service';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('register')
  async register(@Body() dto: {
    email: string;
    password: string;
    name: string;
    companyId: string;
  }) {
    return this.authService.register(dto.email, dto.password, dto.name, dto.companyId);
  }

  @Post('login')
  @HttpCode(HttpStatus.OK)
  async login(@Body() dto: { email: string; password: string }) {
    return this.authService.login(dto.email, dto.password);
  }
}
EOF
```

**Acceptance Criteria:**

- `curl -X POST http://localhost:3000/auth/login -H "Content-Type: application/json" -d '{"email":"admin@ncs.co.th","password":"admin123"}'` returns JWT token
- Token contains user information and can be decoded

**Rollback:** `git stash` if module has errors

---

### Step 2: Expand Database Schema (10:30-12:00)

#### 2.1 Update Prisma Schema with Complete Models

```prisma
// prisma/schema.prisma
cat > prisma/schema.prisma << 'EOF'
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Company {
  id        String   @id @default(uuid())
  name      String   @unique
  taxId     String?  @unique @map("tax_id")
  tier      String   @default("STANDARD")
  users     User[]
  orders    Order[]
  quotes    Quote[]
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  @@map("companies")
}

model User {
  id         String   @id @default(uuid())
  email      String   @unique
  password   String
  name       String
  role       Role     @default(USER)
  companyId  String   @map("company_id")
  company    Company  @relation(fields: [companyId], references: [id])
  orders     Order[]
  quotes     Quote[]
  carts      Cart[]
  createdAt  DateTime @default(now()) @map("created_at")
  
  @@map("users")
}

enum Role {
  USER
  ADMIN
  PURCHASER
  APPROVER
}

model Category {
  id          String    @id @default(uuid())
  name        String    @unique
  nameEn      String    @map("name_en")
  nameTh      String    @map("name_th")
  description String?
  products    Product[]
  createdAt   DateTime  @default(now()) @map("created_at")
  
  @@map("categories")
}

model Product {
  id          String      @id @default(uuid())
  sku         String      @unique
  nameEn      String      @map("name_en")
  nameTh      String      @map("name_th")
  description String?
  price       Decimal     @db.Decimal(12, 2)
  stock       Int         @default(0)
  categoryId  String      @map("category_id")
  category    Category    @relation(fields: [categoryId], references: [id])
  cartItems   Cart[]
  orderItems  OrderItem[]
  quoteItems  QuoteItem[]
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")
  
  @@map("products")
}

model Cart {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id])
  productId String   @map("product_id")
  product   Product  @relation(fields: [productId], references: [id])
  quantity  Int
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  @@unique([userId, productId])
  @@map("carts")
}

model Quote {
  id        String      @id @default(uuid())
  quoteNo   String      @unique @map("quote_no")
  companyId String      @map("company_id")
  company   Company     @relation(fields: [companyId], references: [id])
  userId    String      @map("user_id")
  user      User        @relation(fields: [userId], references: [id])
  status    QuoteStatus @default(PENDING)
  total     Decimal     @db.Decimal(12, 2)
  items     QuoteItem[]
  order     Order?
  validUntil DateTime   @map("valid_until")
  createdAt DateTime    @default(now()) @map("created_at")
  
  @@map("quotes")
}

model QuoteItem {
  id        String  @id @default(uuid())
  quoteId   String  @map("quote_id")
  quote     Quote   @relation(fields: [quoteId], references: [id])
  productId String  @map("product_id")
  product   Product @relation(fields: [productId], references: [id])
  quantity  Int
  unitPrice Decimal @db.Decimal(12, 2) @map("unit_price")
  
  @@map("quote_items")
}

enum QuoteStatus {
  PENDING
  SENT
  ACCEPTED
  REJECTED
  EXPIRED
}

model Order {
  id        String      @id @default(uuid())
  orderNo   String      @unique @map("order_no")
  companyId String      @map("company_id")
  company   Company     @relation(fields: [companyId], references: [id])
  userId    String      @map("user_id")
  user      User        @relation(fields: [userId], references: [id])
  quoteId   String?     @unique @map("quote_id")
  quote     Quote?      @relation(fields: [quoteId], references: [id])
  status    OrderStatus @default(PENDING)
  total     Decimal     @db.Decimal(12, 2)
  items     OrderItem[]
  payment   Payment?
  poNumber  String?     @map("po_number")
  createdAt DateTime    @default(now()) @map("created_at")
  
  @@map("orders")
}

model OrderItem {
  id        String  @id @default(uuid())
  orderId   String  @map("order_id")
  order     Order   @relation(fields: [orderId], references: [id])
  productId String  @map("product_id")
  product   Product @relation(fields: [productId], references: [id])
  quantity  Int
  unitPrice Decimal @db.Decimal(12, 2) @map("unit_price")
  
  @@map("order_items")
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}

model Payment {
  id              String   @id @default(uuid())
  orderId         String   @unique @map("order_id")
  order           Order    @relation(fields: [orderId], references: [id])
  method          String
  status          String   @default("PENDING")
  amount          Decimal  @db.Decimal(12, 2)
  transactionId   String?  @map("transaction_id")
  paymentSlipUrl  String?  @map("payment_slip_url")
  promptpayQr     String?  @map("promptpay_qr")
  createdAt       DateTime @default(now()) @map("created_at")
  
  @@map("payments")
}
EOF
```

#### 2.2 Run Migration

```bash
npx prisma migrate dev --name complete_schema
npx prisma generate
```

**Acceptance Criteria:**

- Migration runs without errors
- `npx prisma studio` shows all new tables created
- Tables have proper relationships visible in Prisma Studio

**Rollback:** `npx prisma migrate reset --force`

---

### Step 3: Product Catalog API (13:00-14:30)

#### 3.1 Create Products Module

```bash
nest g module products
nest g controller products
nest g service products
```

#### 3.2 Implement Product Service

```typescript

// src/products/products.service.ts
cat > src/products/products.service.ts << 'EOF'
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma.service';

@Injectable()
export class ProductsService {
  constructor(private prisma: PrismaService) {}

  async findAll(search?: string, categoryId?: string) {
    const where: any = {};
    
    if (search) {
      where.OR = [
        { nameEn: { contains: search, mode: 'insensitive' } },
        { nameTh: { contains: search, mode: 'insensitive' } },
        { sku: { contains: search, mode: 'insensitive' } },
      ];
    }
    
    if (categoryId) {
      where.categoryId = categoryId;
    }

    return this.prisma.product.findMany({
      where,
      include: { category: true },
    });
  }

  async findOne(id: string) {
    return this.prisma.product.findUnique({
      where: { id },
      include: { category: true },
    });
  }

  async create(data: any) {
    return this.prisma.product.create({
      data,
      include: { category: true },
    });
  }

  async update(id: string, data: any) {
    return this.prisma.product.update({
      where: { id },
      data,
      include: { category: true },
    });
  }
}
EOF
```

#### 3.3 Create Products Controller

```typescript
// src/products/products.controller.ts
cat > src/products/products.controller.ts << 'EOF'
import { Controller, Get, Post, Put, Param, Query, Body, UseGuards } from '@nestjs/common';
import { ProductsService } from './products.service';
import { AuthGuard } from '@nestjs/passport';

@Controller('products')
export class ProductsController {
  constructor(private productsService: ProductsService) {}

  @Get()
  async findAll(
    @Query('search') search?: string,
    @Query('categoryId') categoryId?: string,
  ) {
    return this.productsService.findAll(search, categoryId);
  }

  @Get(':id')
  async findOne(@Param('id') id: string) {
    return this.productsService.findOne(id);
  }

  @Post()
  @UseGuards(AuthGuard('jwt'))
  async create(@Body() data: any) {
    return this.productsService.create(data);
  }

  @Put(':id')
  @UseGuards(AuthGuard('jwt'))
  async update(@Param('id') id: string, @Body() data: any) {
    return this.productsService.update(id, data);
  }
}
EOF
```

**Acceptance Criteria:**

- `GET http://localhost:3000/products` returns product list
- `GET http://localhost:3000/products?search=Router` filters products
- `GET http://localhost:3000/products/:id` returns single product

**Rollback:** Remove products module if errors occur

---

### Step 4: Database Seeding (14:30-16:00)

#### 4.1 Create Comprehensive Seed Script

```typescript
// prisma/seed.ts
cat > prisma/seed.ts << 'EOF'
import { PrismaClient } from '@prisma/client';
import * as bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  // Clean existing data
  await prisma.orderItem.deleteMany();
  await prisma.order.deleteMany();
  await prisma.quoteItem.deleteMany();
  await prisma.quote.deleteMany();
  await prisma.cart.deleteMany();
  await prisma.product.deleteMany();
  await prisma.category.deleteMany();
  await prisma.user.deleteMany();
  await prisma.company.deleteMany();

  // Create companies
  const ncsCompany = await prisma.company.create({
    data: {
      name: 'NCS Networks',
      taxId: '0105558123456',
      tier: 'ADMIN',
    },
  });

  const testCompany = await prisma.company.create({
    data: {
      name: 'Test Corporation',
      taxId: '0105558654321',
      tier: 'STANDARD',
    },
  });

  // Create users
  const adminPassword = await bcrypt.hash('admin123', 10);
  const userPassword = await bcrypt.hash('user123', 10);

  await prisma.user.createMany({
    data: [
      {
        email: 'admin@ncs.co.th',
        password: adminPassword,
        name: 'System Admin',
        role: 'ADMIN',
        companyId: ncsCompany.id,
      },
      {
        email: 'sales@ncs.co.th',
        password: userPassword,
        name: 'Sales User',
        role: 'USER',
        companyId: ncsCompany.id,
      },
      {
        email: 'buyer@test.com',
        password: userPassword,
        name: 'Test Buyer',
        role: 'PURCHASER',
        companyId: testCompany.id,
      },
    ],
  });

  // Create categories
  const networkingCategory = await prisma.category.create({
    data: {
      name: 'networking',
      nameEn: 'Networking Equipment',
      nameTh: 'อุปกรณ์เครือข่าย',
      description: 'Switches, Routers, and Network Infrastructure',
    },
  });

  const securityCategory = await prisma.category.create({
    data: {
      name: 'security',
      nameEn: 'Security Solutions',
      nameTh: 'ระบบความปลอดภัย',
      description: 'Firewalls, VPN, and Security Appliances',
    },
  });

  const wirelessCategory = await prisma.category.create({
    data: {
      name: 'wireless',
      nameEn: 'Wireless Solutions',
      nameTh: 'อุปกรณ์ไร้สาย',
      description: 'Access Points, Controllers, and Wireless Infrastructure',
    },
  });

  // Create products
  await prisma.product.createMany({
    data: [
      // Networking products
      {
        sku: 'SW-24P-1G',
        nameEn: '24-Port Gigabit Managed Switch',
        nameTh: 'สวิตช์ 24 พอร์ต กิกะบิต แบบจัดการได้',
        description: 'Enterprise-grade 24-port gigabit managed switch with PoE+',
        price: 15000,
        stock: 25,
        categoryId: networkingCategory.id,
      },
      {
        sku: 'SW-48P-10G',
        nameEn: '48-Port 10G Switch',
        nameTh: 'สวิตช์ 48 พอร์ต 10 กิกะบิต',
        description: 'High-performance 48-port 10G switch for data centers',
        price: 85000,
        stock: 8,
        categoryId: networkingCategory.id,
      },
      {
        sku: 'RT-ENT-5G',
        nameEn: 'Enterprise 5G Router',
        nameTh: 'เราเตอร์องค์กร 5G',
        description: 'Multi-WAN router with 5G support and failover',
        price: 32000,
        stock: 15,
        categoryId: networkingCategory.id,
      },
      // Security products
      {
        sku: 'FW-UTM-500',
        nameEn: 'UTM Firewall 500',
        nameTh: 'ไฟร์วอลล์ UTM 500',
        description: 'Unified Threat Management firewall for medium businesses',
        price: 45000,
        stock: 12,
        categoryId: securityCategory.id,
      },
      {
        sku: 'VPN-GW-100',
        nameEn: 'VPN Gateway 100 Users',
        nameTh: 'เกตเวย์ VPN 100 ผู้ใช้',
        description: 'Secure VPN gateway supporting up to 100 concurrent users',
        price: 28000,
        stock: 20,
        categoryId: securityCategory.id,
      },
      // Wireless products
      {
        sku: 'AP-AC-PRO',
        nameEn: 'WiFi 6 Access Point Pro',
        nameTh: 'จุดกระจายสัญญาณ WiFi 6 โปร',
        description: 'High-density WiFi 6 access point for enterprise',
        price: 8500,
        stock: 50,
        categoryId: wirelessCategory.id,
      },
      {
        sku: 'WLC-500',
        nameEn: 'Wireless Controller 500 APs',
        nameTh: 'ตัวควบคุมไร้สาย 500 จุด',
        description: 'Centralized wireless controller for up to 500 access points',
        price: 120000,
        stock: 5,
        categoryId: wirelessCategory.id,
      },
    ],
  });

  console.log('✅ Database seeded successfully!');
  console.log('Companies:', 2);
  console.log('Users:', 3);
  console.log('Categories:', 3);
  console.log('Products:', 7);
}

main()
  .catch((e) => {
    console.error('❌ Seed error:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
EOF
```

#### 4.2 Update package.json with Seed Command

```bash
npm pkg set prisma.seed="ts-node prisma/seed.ts"
npm install --save-dev ts-node @types/node
```

#### 4.3 Run Seeding

```bash
npx prisma db seed
```

**Acceptance Criteria:**

- Seed script runs without errors
- `npx prisma studio` shows all seed data
- Can login with seeded users: admin@ncs.co.th / admin123

**Rollback:** `npx prisma migrate reset --force` to clear and reseed

---

### Step 5: Integration Testing (16:00-17:00)

#### 5.1 Test Authentication Flow

```bash
# Test login with seeded admin
curl -X POST http://localhost:3000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@ncs.co.th","password":"admin123"}' | jq

# Save the token
TOKEN="<copy_token_from_above>"

# Test protected endpoint
curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:3000/products
```

#### 5.2 Test Product Endpoints

```bash
# Get all products
curl http://localhost:3000/products | jq

# Search products
curl "http://localhost:3000/products?search=Switch" | jq

# Get single product (use ID from list)
curl http://localhost:3000/products/<product_id> | jq
```

#### 5.3 Verify Database Relationships

```bash
# Open Prisma Studio to visually verify
npx prisma studio

# Check relationships:
# - Users linked to Companies
# - Products linked to Categories
# - All foreign keys properly set
```

**Acceptance Criteria:**

- All API endpoints return expected data
- JWT authentication works
- Search and filtering functions correctly
- Database relationships intact

**Rollback:** Fix specific failing endpoints

---

### Step 6: Documentation & Commit (17:00-18:00)

#### 6.1 Update API Documentation

```markdown
# backend/API.md
cat > backend/API.md << 'EOF'
# NCS B2B E-Commerce API Documentation

## Base URL
Development: `http://localhost:3000`

## Authentication
All protected endpoints require JWT token in Authorization header:
```

Authorization: Bearer <token>

```

## Endpoints

### Auth
- `POST /auth/register` - Register new user
- `POST /auth/login` - Login (returns JWT)

### Products
- `GET /products` - List all products (public)
  - Query params: `search`, `categoryId`
- `GET /products/:id` - Get product details (public)
- `POST /products` - Create product (protected, admin)
- `PUT /products/:id` - Update product (protected, admin)

### Health Check
- `GET /health` - API health status

## Test Credentials
- Admin: admin@ncs.co.th / admin123
- User: buyer@test.com / user123
EOF
```

#### 6.2 Commit Changes

```bash
cd ~/Desktop/Project_Hiroshima/ncs-ecom
git add .
git commit -m "feat: implement auth, products API, and complete schema

- JWT authentication with login/register endpoints
- Complete Prisma schema for e-commerce models
- Product catalog API with search functionality  
- Comprehensive seed data (7 products, 3 users, 2 companies)
- Protected routes with Passport JWT strategy
- API documentation

Completed: Auth module (REQ-002), Product catalog (REQ-005)
Status: Day 4 complete, ready for cart/RFQ implementation"

git push origin main
```

#### 6.3 Update Project Board

```bash
# Update GitHub issues
gh issue comment <auth-issue-id> --body "✅ Authentication implemented with JWT"
gh issue comment <catalog-issue-id> --body "✅ Product catalog API complete with search"
```

---

## End of Day Checklist

### Completed Features

- [x] JWT Authentication (login/register)
- [x] Complete database schema (all models)
- [x] Product catalog API with search
- [x] Database seeded with realistic data
- [x] Protected routes implementation
- [x] API documentation

### Verification Commands

```bash
# All services healthy
docker compose ps

# Backend running
curl http://localhost:3000/health

# Auth working
curl -X POST http://localhost:3000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@ncs.co.th","password":"admin123"}'

# Products API working
curl http://localhost:3000/products
```

### Files Created/Modified

- `src/auth/*` - Authentication module
- `src/products/*` - Products module
- `prisma/schema.prisma` - Complete schema
- `prisma/seed.ts` - Seed data
- `backend/API.md` - API documentation

---

## Day 5 Preview

Tomorrow (September 30, 2025) will focus on:

1. **Shopping Cart Implementation** - Add to cart, view cart, update quantities
2. **RFQ Module** - Quote request from cart
3. **Order Processing** - Quote to order conversion
4. **Frontend Integration** - Connect Next.js to backend APIs

This maintains momentum toward the Week 1 completion targets and January 11, 2026 launch.

---

**Status:** Day 4 execution plan ready. With authentication and product catalog complete, the project has recovered from the Day 3 Prisma blocker and is back on track with core e-commerce functionality.