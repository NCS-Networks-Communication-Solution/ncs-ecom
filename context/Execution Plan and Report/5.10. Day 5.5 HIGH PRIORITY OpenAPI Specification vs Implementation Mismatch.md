# How to Fix OpenAPI Specification vs Implementation Mismatch

## Problem Analysis

Your OpenAPI specification[11] promises functionality that doesn't exist in the actual implementation[8][9][7]. This creates integration failures and breaks API consumer expectations.

## Major Mismatches Identified

### 1. Missing `/auth/refresh` Endpoint
**OpenAPI Promise:** POST `/auth/refresh` with refreshToken body
**Current Implementation:** Only has `/auth/register` and `/auth/login`[8]
**Impact:** Frontend cannot refresh expired tokens

### 2. Server URL Prefix Mismatch  
**OpenAPI Promise:** `http://localhost:3000/api` (with `/api` prefix)[11]
**Current Implementation:** No global prefix, routes go directly to controllers
**Impact:** All API calls with `/api` prefix will fail

### 3. Missing Category Endpoints
**OpenAPI Promise:** GET `/categories` with parentId filter[11]
**Current Implementation:** No categories controller exists
**Impact:** Frontend cannot load product categories

### 4. Missing Products Pagination & Filtering
**OpenAPI Promise:** `page`, `limit`, `minPrice`, `maxPrice` parameters[11]
**Current Implementation:** Only supports `search` and `categoryId`[9][10]
**Impact:** Cannot implement product browsing with pagination or price filters

### 5. Cart API Structure Mismatch
**OpenAPI Promise:** POST `/cart/items` and PATCH `/cart/items/{itemId}`[11]
**Current Implementation:** POST `/cart/add` and PUT `/cart/item/:productId`[7]
**Impact:** Different URL structure breaks API consumers

## Step-by-Step Fix Implementation

### Fix 1: Add Missing `/auth/refresh` Endpoint

**Update auth.controller.ts:**
```typescript
import { Body, Controller, HttpCode, HttpStatus, Post } from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('register')
  async register(@Body() dto: RegisterDto) {
    return this.authService.register(dto);
  }

  @Post('login')
  @HttpCode(HttpStatus.OK)
  async login(@Body() dto: LoginDto) {
    return this.authService.login(dto);
  }

  // ADD THIS NEW ENDPOINT
  @Post('refresh')
  @HttpCode(HttpStatus.OK)
  async refresh(@Body() body: { refreshToken: string }) {
    return this.authService.refreshToken(body.refreshToken);
  }
}
```

**Add refresh method to auth.service.ts:**
```typescript
// Add this method to AuthService class
async refreshToken(refreshToken: string): Promise<AuthResponse> {
  try {
    // Verify the refresh token
    const payload = this.jwtService.verify(refreshToken);
    
    if (payload.type !== 'refresh') {
      throw new UnauthorizedException('Invalid token type');
    }

    // Check if refresh token exists in database
    const storedToken = await this.prisma.refresh_tokens.findFirst({
      where: { 
        userId: payload.sub,
        expiresAt: { gt: new Date() }
      }
    });

    if (!storedToken) {
      throw new UnauthorizedException('Refresh token expired or not found');
    }

    // Verify token hash matches
    const isValid = await bcrypt.compare(refreshToken, storedToken.tokenHash);
    if (!isValid) {
      throw new UnauthorizedException('Invalid refresh token');
    }

    // Get user and generate new tokens
    const user = await this.findUserWithCompany(payload.sub);
    if (!user) {
      throw new UnauthorizedException('User not found');
    }

    return this.generateTokens(user as UserWithCompany);
  } catch (error) {
    throw new UnauthorizedException('Invalid refresh token');
  }
}
```

### Fix 2: Add Global API Prefix

**Update main.ts:**
```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // ADD GLOBAL PREFIX TO MATCH OPENAPI SPEC
  app.setGlobalPrefix('api');
  
  // Enable CORS
  app.enableCors({
    origin: ['http://localhost:3000'],
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
    allowedHeaders: ['Content-Type', 'Authorization'],
  });
  
  const port = process.env.PORT || 3001;
  await app.listen(port, '0.0.0.0');
  
  console.log(`ðŸš€ NCS Backend API running on http://localhost:${port}/api`);
}
bootstrap();
```

### Fix 3: Create Categories Controller

**Create categories.controller.ts:**
```typescript
import { Controller, Get, Query } from '@nestjs/common';
import { CategoriesService } from './categories.service';

@Controller('categories')
export class CategoriesController {
  constructor(private categoriesService: CategoriesService) {}

  @Get()
  async findAll(@Query('parentId') parentId?: string) {
    return this.categoriesService.findAll(parentId);
  }
}
```

**Create categories.service.ts:**
```typescript
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma.service';

@Injectable()
export class CategoriesService {
  constructor(private prisma: PrismaService) {}

  async findAll(parentId?: string) {
    const where = parentId ? { parentId } : {};
    
    return this.prisma.categories.findMany({
      where,
      include: {
        _count: {
          select: { products: true }
        }
      },
      orderBy: { nameEn: 'asc' }
    });
  }
}
```

### Fix 4: Add Pagination and Price Filtering to Products

**Update products.controller.ts:**
```typescript
import { Controller, Get, Post, Put, Param, Query, Body, UseGuards } from '@nestjs/common';
import { ProductsService } from './products.service';
import { AuthGuard } from '@nestjs/passport';

@Controller('products')
export class ProductsController {
  constructor(private productsService: ProductsService) {}

  @Get()
  async findAll(
    @Query('search') search?: string,
    @Query('categoryId') categoryId?: string,
    @Query('minPrice') minPrice?: number,
    @Query('maxPrice') maxPrice?: number,
    @Query('page') page?: number,
    @Query('limit') limit?: number,
  ) {
    return this.productsService.findAll({
      search,
      categoryId,
      minPrice,
      maxPrice,
      page: page || 1,
      limit: Math.min(limit || 20, 100), // Cap at 100 as per OpenAPI spec
    });
  }

  @Get(':id')
  async findOne(@Param('id') id: string) {
    return this.productsService.findOne(id);
  }

  @Post()
  @UseGuards(AuthGuard('jwt'))
  async create(@Body() data: any) {
    return this.productsService.create(data);
  }

  @Put(':id')
  @UseGuards(AuthGuard('jwt'))
  async update(@Param('id') id: string, @Body() data: any) {
    return this.productsService.update(id, data);
  }
}
```

**Update products.service.ts:**
```typescript
import { Injectable } from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { PrismaService } from '../prisma.service';

interface FindAllOptions {
  search?: string;
  categoryId?: string;
  minPrice?: number;
  maxPrice?: number;
  page: number;
  limit: number;
}

@Injectable()
export class ProductsService {
  constructor(private prisma: PrismaService) {}

  async findAll(options: FindAllOptions) {
    const { search, categoryId, minPrice, maxPrice, page, limit } = options;
    const skip = (page - 1) * limit;
    
    const where: Prisma.productsWhereInput = {};

    // Search filter
    if (search) {
      where.OR = [
        { nameEn: { contains: search, mode: 'insensitive' } },
        { nameTh: { contains: search, mode: 'insensitive' } },
        { sku: { contains: search, mode: 'insensitive' } },
      ];
    }

    // Category filter
    if (categoryId) {
      where.categoryId = categoryId;
    }

    // Price filters
    if (minPrice !== undefined || maxPrice !== undefined) {
      where.price = {};
      if (minPrice !== undefined) {
        where.price.gte = minPrice;
      }
      if (maxPrice !== undefined) {
        where.price.lte = maxPrice;
      }
    }

    // Get total count for pagination
    const total = await this.prisma.products.count({ where });

    // Get products with pagination
    const items = await this.prisma.products.findMany({
      where,
      include: { categories: true },
      skip,
      take: limit,
      orderBy: { nameEn: 'asc' },
    });

    return {
      items,
      total,
      page,
      limit,
      hasMore: skip + items.length < total,
    };
  }

  async findOne(id: string) {
    return this.prisma.products.findUnique({
      where: { id },
      include: { categories: true },
    });
  }

  async create(data: any) {
    return this.prisma.products.create({
      data,
      include: { categories: true },
    });
  }

  async update(id: string, data: any) {
    return this.prisma.products.update({
      where: { id },
      data,
      include: { categories: true },
    });
  }

  async remove(id: string) {
    return this.prisma.products.delete({
      where: { id },
    });
  }
}
```

### Fix 5: Align Cart API Structure

**Update cart.controller.ts to match OpenAPI spec:**
```typescript
import { Body, Controller, Delete, Get, Param, Post, Patch, Request, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { CartService } from './cart.service';
import { AddToCartDto } from './dto/add-to-cart.dto';
import { UpdateCartItemDto } from './dto/update-cart-item.dto';

@Controller('cart')
@UseGuards(AuthGuard('jwt'))
export class CartController {
  constructor(private readonly cartService: CartService) {}

  @Get()
  getCart(@Request() req: any) {
    return this.cartService.getCart(req.user.userId);
  }

  @Delete()
  clearCart(@Request() req: any) {
    return this.cartService.clearCart(req.user.userId);
  }

  // CHANGE TO MATCH OPENAPI: /cart/items instead of /cart/add
  @Post('items')
  addToCart(@Request() req: any, @Body() dto: AddToCartDto) {
    return this.cartService.addToCart(req.user.userId, dto);
  }

  // CHANGE TO MATCH OPENAPI: PATCH /cart/items/{itemId} instead of PUT /cart/item/:productId
  @Patch('items/:itemId')
  updateItem(
    @Request() req: any,
    @Param('itemId') itemId: string,
    @Body() dto: UpdateCartItemDto,
  ) {
    return this.cartService.updateCartItem(req.user.userId, itemId, dto.quantity);
  }

  // CHANGE TO MATCH OPENAPI: DELETE /cart/items/{itemId}
  @Delete('items/:itemId')
  removeItem(@Request() req: any, @Param('itemId') itemId: string) {
    return this.cartService.removeFromCart(req.user.userId, itemId);
  }
}
```

## Update Frontend to Use New API Structure

### Update Frontend URLs for New API Prefix

**Update AdminContext.tsx:**
```typescript
const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:3001/api";
```

**Update smoke.mjs:**
```javascript
const API_URL = process.env.NEXT_PUBLIC_API_URL ?? 'http://localhost:3001/api';
```

**Update page.tsx and any other frontend files that reference the API.**

## Module Registration

**Update app.module.ts to include new modules:**
```typescript
import { Module } from '@nestjs/common';
import { AuthModule } from './auth/auth.module';
import { ProductsModule } from './products/products.module';
import { CartModule } from './cart/cart.module';
import { CategoriesModule } from './categories/categories.module'; // ADD THIS
import { PrismaService } from './prisma.service';

@Module({
  imports: [
    AuthModule,
    ProductsModule,
    CartModule,
    CategoriesModule, // ADD THIS
  ],
  providers: [PrismaService],
})
export class AppModule {}
```

**Create categories.module.ts:**
```typescript
import { Module } from '@nestjs/common';
import { CategoriesController } from './categories.controller';
import { CategoriesService } from './categories.service';
import { PrismaService } from '../prisma.service';

@Module({
  controllers: [CategoriesController],
  providers: [CategoriesService, PrismaService],
})
export class CategoriesModule {}
```

## Testing the Fixes

### 1. Test Auth Endpoints
```bash
# Register
curl -X POST http://localhost:3001/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email": "test@example.com", "password": "test123", "name": "Test User", "companyId": "uuid"}'

# Login
curl -X POST http://localhost:3001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "test@example.com", "password": "test123"}'

# Refresh (using token from login response)
curl -X POST http://localhost:3001/api/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{"refreshToken": "eyJ..."}'
```

### 2. Test Products with Pagination
```bash
# List products with pagination
curl "http://localhost:3001/api/products?page=1&limit=10&minPrice=100&maxPrice=1000"

# Search products
curl "http://localhost:3001/api/products?search=laptop&page=1&limit=5"
```

### 3. Test Categories
```bash
# List all categories
curl http://localhost:3001/api/categories

# List categories by parent
curl "http://localhost:3001/api/categories?parentId=uuid"
```

### 4. Test Updated Cart API
```bash
# Add to cart (note: /cart/items instead of /cart/add)
curl -X POST http://localhost:3001/api/cart/items \
  -H "Authorization: Bearer eyJ..." \
  -H "Content-Type: application/json" \
  -d '{"productId": "uuid", "quantity": 1}'

# Update cart item (note: PATCH and itemId)
curl -X PATCH http://localhost:3001/api/cart/items/itemId \
  -H "Authorization: Bearer eyJ..." \
  -H "Content-Type: application/json" \
  -d '{"quantity": 2}'
```

## Summary of Changes

1. **âœ… Added `/auth/refresh` endpoint** - Matches OpenAPI specification
2. **âœ… Added global `/api` prefix** - All endpoints now under `/api`
3. **âœ… Created categories controller** - Implements `/categories` endpoint
4. **âœ… Enhanced products pagination** - Added page, limit, minPrice, maxPrice filters
5. **âœ… Aligned cart API structure** - Changed URLs to match OpenAPI specification
6. **âœ… Updated frontend API URLs** - Added `/api` prefix to all calls

These changes ensure your implementation matches the published OpenAPI contract, enabling reliable API integration and preventing consumer failures.