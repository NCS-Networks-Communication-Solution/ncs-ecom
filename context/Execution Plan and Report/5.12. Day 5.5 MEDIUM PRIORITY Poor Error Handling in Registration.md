# How to Fix Poor Error Handling in Registration

## Problem Analysis

Your current `register` method in `AuthService` doesn't handle **unique constraint violations** when users attempt to register with existing email addresses. This causes database errors to bubble up as 500 Internal Server errors instead of the proper 409 Conflict response documented in your OpenAPI specification.openapi.yaml

## Current Implementation Issues

## **Missing Error Handling in AuthService**

Looking at your current `auth.service.ts`, the register method lacks proper error catching:auth.service.ts

typescript

`async register(dto: RegisterDto): Promise<AuthResponse> {   const hashedPassword = await bcrypt.hash(dto.password, 10);      const createdUser = await this.prisma.users.create({     data: {       id: randomUUID(),       email: dto.email,       password: hashedPassword,       name: dto.name,       role: 'USER',       companies: {         connect: { id: dto.companyId },       },     },   });      // ... rest of method }`

**Problem**: If `dto.email` already exists, Prisma throws a unique constraint error that isn't caught, resulting in a 500 error instead of 409 Conflict.

## Comprehensive Fix Implementation

## **Step 1: Add Proper Exception Imports**

Update your `auth.service.ts` imports:

typescript

`import {    Injectable,    UnauthorizedException,    ConflictException,   BadRequestException  } from '@nestjs/common'; import { Prisma } from '@prisma/client'; // ... other imports`

## **Step 2: Enhance Register Method with Error Handling**

Replace your current register method with this improved version:

typescript

`async register(dto: RegisterDto): Promise<AuthResponse> {   try {     // Check if email already exists before attempting creation     const existingUser = await this.prisma.users.findUnique({       where: { email: dto.email }     });     if (existingUser) {       throw new ConflictException('Email address is already registered');     }     // Verify company exists before creating user     const company = await this.prisma.companies.findUnique({       where: { id: dto.companyId }     });     if (!company) {       throw new BadRequestException('Invalid company ID');     }     const hashedPassword = await bcrypt.hash(dto.password, 10);     const createdUser = await this.prisma.users.create({       data: {         id: randomUUID(),         email: dto.email,         password: hashedPassword,         name: dto.name,         role: 'USER',         companies: {           connect: { id: dto.companyId },         },       },     });     const user = await this.findUserWithCompany(createdUser.id);     if (!user) {       throw new UnauthorizedException('Unable to load created user');     }     return this.generateTokens(user);   } catch (error) {     // Handle known exceptions first     if (error instanceof ConflictException ||          error instanceof BadRequestException ||          error instanceof UnauthorizedException) {       throw error;     }     // Handle Prisma-specific errors     if (error instanceof Prisma.PrismaClientKnownRequestError) {       // P2002: Unique constraint violation       if (error.code === 'P2002') {         const field = error.meta?.target as string[] | undefined;         if (field?.includes('email')) {           throw new ConflictException('Email address is already registered');         }         throw new ConflictException('Registration failed due to duplicate data');       }              // P2025: Record not found (company doesn't exist)       if (error.code === 'P2025') {         throw new BadRequestException('Invalid company ID');       }     }     // Handle other database connection issues     if (error instanceof Prisma.PrismaClientInitializationError) {       throw new BadRequestException('Database connection failed');     }     // Log unexpected errors for debugging     console.error('Unexpected registration error:', error);     throw new BadRequestException('Registration failed due to an unexpected error');   } }`

## **Step 3: Create Standardized Error Response DTOs**

Create `src/auth/dto/error-response.dto.ts`:

typescript

`export class ErrorResponseDto {   code: string;   message: string;   details?: Array<{     field: string;     message: string;   }>; }`

## **Step 4: Add Global Exception Filter (Optional but Recommended)**

Create `src/filters/http-exception.filter.ts`:

typescript

`import {   ExceptionFilter,   Catch,   ArgumentsHost,   HttpException,   HttpStatus, } from '@nestjs/common'; import { Request, Response } from 'express'; import { Prisma } from '@prisma/client'; @Catch() export class AllExceptionsFilter implements ExceptionFilter {   catch(exception: unknown, host: ArgumentsHost) {     const ctx = host.switchToHttp();     const response = ctx.getResponse<Response>();     const request = ctx.getRequest<Request>();     let status = HttpStatus.INTERNAL_SERVER_ERROR;     let message = 'Internal server error';     let code = 'INTERNAL_ERROR';     if (exception instanceof HttpException) {       status = exception.getStatus();       const exceptionResponse = exception.getResponse() as any;       message = exceptionResponse.message || exception.message;       code = this.getErrorCode(status);     } else if (exception instanceof Prisma.PrismaClientKnownRequestError) {       // Handle Prisma errors that weren't caught in services       switch (exception.code) {         case 'P2002':           status = HttpStatus.CONFLICT;           message = 'Duplicate entry detected';           code = 'DUPLICATE_ERROR';           break;         case 'P2025':           status = HttpStatus.NOT_FOUND;           message = 'Record not found';           code = 'NOT_FOUND';           break;         default:           status = HttpStatus.BAD_REQUEST;           message = 'Database operation failed';           code = 'DATABASE_ERROR';       }     }     const errorResponse = {       code,       message,       timestamp: new Date().toISOString(),       path: request.url,     };     response.status(status).json(errorResponse);   }   private getErrorCode(status: number): string {     switch (status) {       case HttpStatus.BAD_REQUEST:         return 'BAD_REQUEST';       case HttpStatus.UNAUTHORIZED:         return 'UNAUTHORIZED';       case HttpStatus.FORBIDDEN:         return 'FORBIDDEN';       case HttpStatus.NOT_FOUND:         return 'NOT_FOUND';       case HttpStatus.CONFLICT:         return 'CONFLICT';       default:         return 'INTERNAL_ERROR';     }   } }`

## **Step 5: Update Controller with Proper HTTP Status Codes**

Update your `auth.controller.ts`:auth.controller.ts

typescript

`import {    Body,    Controller,    HttpCode,    HttpStatus,    Post,   HttpException } from '@nestjs/common'; import { AuthService } from './auth.service'; import { RegisterDto } from './dto/register.dto'; import { LoginDto } from './dto/login.dto'; @Controller('auth') export class AuthController {   constructor(private authService: AuthService) {}   @Post('register')   @HttpCode(HttpStatus.CREATED) // Explicitly set 201 for successful registration   async register(@Body() dto: RegisterDto) {     try {       return await this.authService.register(dto);     } catch (error) {       // Let NestJS handle the exception properly       throw error;     }   }   @Post('login')   @HttpCode(HttpStatus.OK)   async login(@Body() dto: LoginDto) {     return this.authService.login(dto);   } }`

## **Step 6: Register Global Exception Filter (Optional)**

If you created the global exception filter, register it in your `main.ts`:

typescript

`import { AllExceptionsFilter } from './filters/http-exception.filter'; async function bootstrap() {   const app = await NestFactory.create(AppModule);      // Register global exception filter   app.useGlobalFilters(new AllExceptionsFilter());      // ... rest of your configuration }`

## Testing the Fixed Error Handling

## **Test Duplicate Email Registration**

bash

`# First registration should succeed (201 Created) curl -X POST http://localhost:3001/api/auth/register \   -H "Content-Type: application/json" \   -d '{     "email": "test@example.com",    "password": "password123",    "name": "Test User",    "companyId": "valid-uuid"  }' # Second registration with same email should return 409 Conflict curl -X POST http://localhost:3001/api/auth/register \   -H "Content-Type: application/json" \   -d '{     "email": "test@example.com",    "password": "password456",    "name": "Another User",    "companyId": "valid-uuid"  }'`

## **Expected Response for Conflict**

json

`{   "code": "CONFLICT",   "message": "Email address is already registered",   "timestamp": "2025-10-01T07:00:00.000Z",   "path": "/api/auth/register" }`

## **Test Invalid Company ID**

bash

`curl -X POST http://localhost:3001/api/auth/register \   -H "Content-Type: application/json" \   -d '{     "email": "newuser@example.com",    "password": "password123",    "name": "New User",    "companyId": "invalid-uuid"  }'`

## Benefits Achieved

**✅ Proper HTTP Status Codes**: 409 Conflict for duplicates, 400 Bad Request for invalid data  
**✅ API Contract Compliance**: Matches OpenAPI specification exactlyopenapi.yaml  
**✅ Better User Experience**: Clear error messages instead of generic 500 errors  
**✅ Proactive Validation**: Checks for conflicts before database operations  
**✅ Comprehensive Error Handling**: Covers all Prisma error scenarios  
**✅ Debugging Support**: Logs unexpected errors for investigation

This comprehensive fix transforms your registration endpoint from having poor error handling into a robust, user-friendly API that properly communicates validation failures and maintains API contract compliance.

1. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/100575622/2567157c-9fbc-4d8d-ba70-f599ee36d73d/openapi.yaml](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/100575622/2567157c-9fbc-4d8d-ba70-f599ee36d73d/openapi.yaml)
2. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/100575622/fbf23c44-6efa-486f-9f4d-9a12f9cd88ab/auth.service.ts](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/100575622/fbf23c44-6efa-486f-9f4d-9a12f9cd88ab/auth.service.ts)
3. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/100575622/3b3681a1-931a-48fc-8ac3-1e06c669f28d/auth.controller.ts](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/100575622/3b3681a1-931a-48fc-8ac3-1e06c669f28d/auth.controller.ts)