# How to Fix Unauthorized Product Management APIs

## Problem Analysis

Your product management endpoints have **critical security vulnerabilities** that allow any authenticated user to create, modify, or delete products without proper authorization or data validation.

## Current Security Flaws

## **Insufficient Access Control**

The current implementation only uses `@UseGuards(AuthGuard('jwt'))`, which means any authenticated user (including regular customers) can modify your product catalog.products.controller.ts

## **No Data Validation**

Controllers accept `@Body() data: any`, allowing malformed or malicious data to reach your database.products.service.ts+1

## **Missing Required Fields**

Raw body forwarding bypasses essential fields like `updatedAt`, causing Prisma database errors.products.service.ts

## Comprehensive Security Fix

## **Step 1: Create Role-Based Access Guard**

Create `src/guards/roles.guard.ts`:

typescript

``import {   Injectable,   CanActivate,   ExecutionContext,   ForbiddenException, } from '@nestjs/common'; import { Reflector } from '@nestjs/core'; import { AdminRole } from '../types/admin.types'; @Injectable() export class RolesGuard implements CanActivate {   constructor(private reflector: Reflector) {}   canActivate(context: ExecutionContext): boolean {     const requiredRoles = this.reflector.getAllAndOverride<AdminRole[]>('roles', [       context.getHandler(),       context.getClass(),     ]);     if (!requiredRoles) {       return true;     }     const { user } = context.switchToHttp().getRequest();          if (!user) {       throw new ForbiddenException('User not authenticated');     }     const hasRole = requiredRoles.includes(user.role);          if (!hasRole) {       throw new ForbiddenException(`Requires one of roles: ${requiredRoles.join(', ')}`);     }     return true;   } }``

Create `src/decorators/roles.decorator.ts`:

typescript

`import { SetMetadata } from '@nestjs/common'; import { AdminRole } from '../types/admin.types'; export const Roles = (...roles: AdminRole[]) => SetMetadata('roles', roles);`

## **Step 2: Create Product DTOs for Validation**

Create `src/products/dto/create-product.dto.ts`:

typescript

`import {   IsString,   IsNumber,   IsOptional,   IsUUID,   IsUrl,   Min,   MaxLength,   IsNotEmpty, } from 'class-validator'; import { Transform } from 'class-transformer'; export class CreateProductDto {   @IsString()   @IsNotEmpty()   @MaxLength(255)   nameEn: string;   @IsString()   @IsNotEmpty()   @MaxLength(255)   nameTh: string;   @IsString()   @IsNotEmpty()   @MaxLength(100)   sku: string;   @IsString()   @IsOptional()   @MaxLength(1000)   descriptionEn?: string;   @IsString()   @IsOptional()   @MaxLength(1000)   descriptionTh?: string;   @IsNumber()   @Min(0)   @Transform(({ value }) => parseFloat(value))   price: number;   @IsNumber()   @Min(0)   @Transform(({ value }) => parseInt(value))   stockQuantity: number;   @IsString()   @IsOptional()   @MaxLength(50)   unit?: string;   @IsUUID()   @IsOptional()   categoryId?: string;   @IsUrl()   @IsOptional()   imageUrl?: string;   @IsString()   @IsOptional()   @MaxLength(50)   status?: string; }`

Create `src/products/dto/update-product.dto.ts`:

typescript

`import { PartialType, OmitType } from '@nestjs/mapped-types'; import { CreateProductDto } from './create-product.dto'; export class UpdateProductDto extends PartialType(   OmitType(CreateProductDto, ['sku'] as const) ) {   // SKU should not be updateable after creation }`

## **Step 3: Secure the Products Controller**

Update your `products.controller.ts`:

typescript

`import {   Controller,   Get,   Post,   Put,   Delete,   Param,   Query,   Body,   UseGuards,   ParseUUIDPipe,   ValidationPipe, } from '@nestjs/common'; import { ProductsService } from './products.service'; import { AuthGuard } from '@nestjs/passport'; import { RolesGuard } from '../guards/roles.guard'; import { Roles } from '../decorators/roles.decorator'; import { CreateProductDto } from './dto/create-product.dto'; import { UpdateProductDto } from './dto/update-product.dto'; import { AdminRole } from '../types/admin.types'; @Controller('products') export class ProductsController {   constructor(private productsService: ProductsService) {}   @Get()   async findAll(     @Query('search') search?: string,     @Query('categoryId') categoryId?: string,   ) {     return this.productsService.findAll(search, categoryId);   }   @Get(':id')   async findOne(@Param('id', ParseUUIDPipe) id: string) {     return this.productsService.findOne(id);   }   @Post()   @UseGuards(AuthGuard('jwt'), RolesGuard)   @Roles('ADMIN', 'APPROVER') // Only ADMIN and APPROVER can create products   async create(@Body(ValidationPipe) createProductDto: CreateProductDto) {     return this.productsService.create(createProductDto);   }   @Put(':id')   @UseGuards(AuthGuard('jwt'), RolesGuard)   @Roles('ADMIN', 'APPROVER') // Only ADMIN and APPROVER can update products   async update(     @Param('id', ParseUUIDPipe) id: string,     @Body(ValidationPipe) updateProductDto: UpdateProductDto,   ) {     return this.productsService.update(id, updateProductDto);   }   @Delete(':id')   @UseGuards(AuthGuard('jwt'), RolesGuard)   @Roles('ADMIN') // Only ADMIN can delete products   async remove(@Param('id', ParseUUIDPipe) id: string) {     return this.productsService.remove(id);   } }`

## **Step 4: Update Products Service with Proper Validation**

Update your `products.service.ts`:

typescript

``import { Injectable, NotFoundException, ConflictException } from '@nestjs/common'; import { Prisma } from '@prisma/client'; import { PrismaService } from '../prisma.service'; import { CreateProductDto } from './dto/create-product.dto'; import { UpdateProductDto } from './dto/update-product.dto'; @Injectable() export class ProductsService {   constructor(private prisma: PrismaService) {}   async findAll(search?: string, categoryId?: string) {     const where: Prisma.productsWhereInput = {};     if (search) {       where.OR = [         { nameEn: { contains: search, mode: 'insensitive' } },         { nameTh: { contains: search, mode: 'insensitive' } },         { sku: { contains: search, mode: 'insensitive' } },       ];     }     if (categoryId) {       where.categoryId = categoryId;     }     return this.prisma.products.findMany({       where,       include: { categories: true },       orderBy: { createdAt: 'desc' },     });   }   async findOne(id: string) {     const product = await this.prisma.products.findUnique({       where: { id },       include: { categories: true },     });     if (!product) {       throw new NotFoundException(`Product with ID ${id} not found`);     }     return product;   }   async create(createProductDto: CreateProductDto) {     try {       // Check if SKU already exists       const existingSku = await this.prisma.products.findUnique({         where: { sku: createProductDto.sku },       });       if (existingSku) {         throw new ConflictException(`Product with SKU ${createProductDto.sku} already exists`);       }       // Verify category exists if provided       if (createProductDto.categoryId) {         const category = await this.prisma.categories.findUnique({           where: { id: createProductDto.categoryId },         });         if (!category) {           throw new NotFoundException(`Category with ID ${createProductDto.categoryId} not found`);         }       }       const productData: Prisma.productsCreateInput = {         ...createProductDto,         createdAt: new Date(),         updatedAt: new Date(),         // Connect category if provided         categories: createProductDto.categoryId           ? { connect: { id: createProductDto.categoryId } }           : undefined,       };       // Remove categoryId from data since we're using connect       delete productData.categoryId;       return this.prisma.products.create({         data: productData,         include: { categories: true },       });     } catch (error) {       if (error instanceof ConflictException || error instanceof NotFoundException) {         throw error;       }       throw new ConflictException('Failed to create product. Check for duplicate SKU or invalid data.');     }   }   async update(id: string, updateProductDto: UpdateProductDto) {     // Check if product exists     await this.findOne(id);     try {       // Verify category exists if provided       if (updateProductDto.categoryId) {         const category = await this.prisma.categories.findUnique({           where: { id: updateProductDto.categoryId },         });         if (!category) {           throw new NotFoundException(`Category with ID ${updateProductDto.categoryId} not found`);         }       }       const productData: Prisma.productsUpdateInput = {         ...updateProductDto,         updatedAt: new Date(), // Always update timestamp         // Connect category if provided         categories: updateProductDto.categoryId           ? { connect: { id: updateProductDto.categoryId } }           : undefined,       };       // Remove categoryId from data since we're using connect       delete productData.categoryId;       return this.prisma.products.update({         where: { id },         data: productData,         include: { categories: true },       });     } catch (error) {       if (error instanceof NotFoundException) {         throw error;       }       throw new ConflictException('Failed to update product. Check for invalid data.');     }   }   async remove(id: string) {     // Check if product exists     await this.findOne(id);     try {       return this.prisma.products.delete({         where: { id },       });     } catch (error) {       throw new ConflictException('Failed to delete product. It may be referenced by other records.');     }   } }``

## **Step 5: Create Admin Types File**

Create `src/types/admin.types.ts`:

typescript

`export type AdminRole = 'ADMIN' | 'APPROVER' | 'PURCHASER' | 'USER'; export interface AdminUser {   id: string;   email: string;   name: string;   role: AdminRole;   company: {     id: string;     name: string;     tier: string;   } | null; }`

## **Step 6: Install Required Dependencies**

bash

`npm install class-validator class-transformer`

## **Step 7: Register Global Validation Pipe**

Update your `main.ts`:

typescript

`import { ValidationPipe } from '@nestjs/common'; async function bootstrap() {   const app = await NestFactory.create(AppModule);      // Enable global validation   app.useGlobalPipes(new ValidationPipe({     whitelist: true, // Strip properties that don't have decorators     forbidNonWhitelisted: true, // Throw error if extra properties are sent     transform: true, // Automatically transform payloads to DTO instances   }));      // ... rest of your configuration }`

## Security Testing

## **Test Role-Based Access Control**

bash

`# Should work (ADMIN role) curl -X POST http://localhost:3001/api/products \   -H "Authorization: Bearer admin-token" \   -H "Content-Type: application/json" \   -d '{"nameEn":"Test Product","nameTh":"ทดสอบ","sku":"TEST001","price":100,"stockQuantity":10}' # Should fail (USER role) curl -X POST http://localhost:3001/api/products \   -H "Authorization: Bearer user-token" \   -H "Content-Type: application/json" \   -d '{"nameEn":"Test Product","nameTh":"ทดสอบ","sku":"TEST001","price":100,"stockQuantity":10}'`

## **Test Data Validation**

bash

`# Should fail (missing required fields) curl -X POST http://localhost:3001/api/products \   -H "Authorization: Bearer admin-token" \   -H "Content-Type: application/json" \   -d '{"nameEn":"Test"}' # Should fail (invalid data types) curl -X POST http://localhost:3001/api/products \   -H "Authorization: Bearer admin-token" \   -H "Content-Type: application/json" \   -d '{"nameEn":"Test","price":"invalid","stockQuantity":"abc"}'`

## Security Benefits Achieved

**✅ Role-Based Access Control**: Only ADMIN and APPROVER can modify products  
**✅ Input Validation**: All data is validated against strict DTOs  
**✅ Required Field Handling**: `updatedAt` and `createdAt` are automatically managed  
**✅ Duplicate Prevention**: SKU uniqueness is enforced  
**✅ Error Handling**: Proper HTTP status codes and error messages  
**✅ Data Integrity**: Foreign key validation for categories

This comprehensive security implementation transforms your vulnerable product endpoints into a properly secured API that prevents unauthorized access and ensures data integrity.AdminContext.tsx+2

1. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/100575622/410ffa64-4e82-4fcc-a802-a5fd38850078/products.controller.ts](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/100575622/410ffa64-4e82-4fcc-a802-a5fd38850078/products.controller.ts)
2. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/100575622/a8d36367-ebef-4997-aa07-d80130666738/products.service.ts](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/100575622/a8d36367-ebef-4997-aa07-d80130666738/products.service.ts)
3. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/100575622/179378c1-a0d6-4b0d-ab30-21b48a750b48/AdminContext.tsx](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/100575622/179378c1-a0d6-4b0d-ab30-21b48a750b48/AdminContext.tsx)