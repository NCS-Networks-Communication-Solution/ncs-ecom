**Outstanding Issues**

- Cart contract still diverges from the published OpenAPI spec: responses omit required fields like id, subtotal, tax, and itemCount, deletes return JSON instead of 204, and the documented /cart/bulk-import endpoint is unimplemented. Any client generated from the spec will fail against the current API. (spec/openapi.yaml:195, spec/openapi.yaml:283, spec/openapi.yaml:787, backend/src/cart/cart.controller.ts:12, backend/src/cart/cart.controller.ts:36, backend/src/cart/cart.service.ts:126)
	- After codex => CSV importing currently assumes simple comma-separated values without quoted commas; extend parsing or add validation tests if real data needs that flexibility. Natural next step: add automated tests for the new bulk import workflow to lock down the spec-aligned behavior.

- Category hierarchy support promised in the spec is stubbed out; parentId queries simply return an empty array because the Prisma model has no parent linkage, level, or product count fields. Consumers expecting hierarchical navigation and counts cannot use the current data. (spec/openapi.yaml:172, spec/openapi.yaml:715, backend/src/categories/categories.service.ts:8, backend/prisma/schema.prisma:24)
	- After codex => Apply the new migration (npx prisma migrate deploy) and reseed after updating your database to pick up the hierarchy.

- Role and tier enumerations drift from the API contract: the spec lists roles ADMIN|PURCHASER|VIEWER|SALES and company tiers STANDARD|BRONZE|SILVER|GOLD, but the code uses ADMIN|APPROVER|PURCHASER|USER and seeds a company with tier ADMIN, so responses violate the documented enums. (spec/openapi.yaml:693, spec/openapi.yaml:709, backend/prisma/schema.prisma:162, backend/prisma/seed.ts:31)
	-  After codex => 
		- Updated prisma/seed.ts to use the new category hierarchy correctly (connecting parents instead of assigning parentId) and kept role/tier values aligned with the refreshed enums. Seeding now matches the revised schema.
		- Consolidated the schema evolution into a single migration 20251001085312_update_role_enum_and_category_hierarchy, adding the category hierarchy columns/constraints and replacing the Role enum with ADMIN|PURCHASER|VIEWER|SALES. Removed the old manual migration stubs to avoid duplicate history.
		- Regenerated the Prisma client so TypeScript knows about the new fields/enums, and ran the migration plus npx prisma db seed to confirm the database seeds cleanly with the updated data.

- Product payloads lack several required fields from the spec (descriptionEn, descriptionTh, specifications, images), and the database stores only a single description, so OpenAPI-based clients or validators will report schema errors. (spec/openapi.yaml:734, backend/prisma/schema.prisma:100, backend/src/products/dto/create-product.dto.ts:4)
	-  After codex => Run npx prisma migrate deploy && npx prisma db seed in any other environment to apply the schema changes, and consider adding UI cues for invalid specifications input since the editor now expects JSON.

- Align backend to published API contract: add global /api prefix, implement refresh token route, categories controller, full product filters, and cart endpoint shapes; update Next.js env usage and smoke tests to the same base URL. Guard with integration tests that mirror the Playthrough requests (context/Execution Plan and Report/5.10. Day 5.5 HIGH PRIORITY OpenAPI Specification vs Implementation Mismatch.md:1).
	- Tests: npm run test:e2e (backend)
	- Next steps (optional): 
		1) Wire the new e2e suite into CI once you’re ready to spin up a real Postgres/Redis pair for automated runs. 
		2) Layer in real Prisma fixtures for these tests when you want to exercise the full persistence flow instead of the current service stubs.
	- which guided the checklist coverage chosen for the e2e validations.
	- Tests: ran docker compose up -d postgres redis followed by npm run test:e2e (backend).
		- Next steps (optional):
			1. Monitor the new CI job; if migrations become redundant, set SKIP_E2E_MIGRATIONS=true in that step after a dedicated migrate stage.
			2. Expand the fixture builder to cover admin endpoints or orders once you want broader smoke coverage.

- Harden authentication and admin surfaces: introduce role-based guard + decorators, DTO validation, and consistent error responses so only admin roles manage catalog data, and the auth flows in the checklist surface meaningful feedback (context/Execution Plan and Report/5.11. Day 5.5 HIGH PRIORITY Unauthorized Product Management APIs.md:1; context/Execution Plan and Report/5.12. Day 5.5 MEDIUM PRIORITY Poor Error Handling in Registration.md:1).
	- - npm run test (backend unit suite)
- npm run test:e2e (backend playthrough against live Postgres/Redis)

- Streamline boot & seed workflow: reconcile port expectations, add .env templates, npm scripts (or a make playthrough) to run compose, migrations, seed, and start both apps with matching API URLs to eliminate the port mismatch noted in the retros (context/NCS B2B E-Commerce Platform – Month 1 Execution Plan (Docker Compose Edition).docx:1; context/Execution Plan and Report/5.9. Day 5.5 HIGH PRIORITY Port Mismatch Between Frontend and Backend.md:1).
	- 

- Document admin/API smoke steps: extend the Playthrough checklist with curl/Postman samples for admin overview, tier updates, and cart CSV import so the non-UI endpoints are validated alongside UI flows; include expected seeded accounts/products from the Prisma seed script reference (context/Execution Plan and Report/0.0.1. Week 1 Execution Report.md:1).














Everything in the repo is demo-ready: backend routes match the technical blueprint, the Docker-backed Postgres/Redis stack seeds correctly, and the frontend consumes the /api endpoints documented in the Month‑1 plan. Use the flow below to spin it up and verify the full integration.

**Terminal Commands**

1. **Pre-flight (run in repo root)**
    
    `node -v # expect ≥18 npm -v docker info # ensure Docker Desktop is running lsof -i :3000 -sTCP:LISTEN # should return nothing (free port) lsof -i :3100 -sTCP:LISTEN # new default frontend port`
    
2. **Prepare env & dependencies (one-off)**
    
    `cp .env.example .env docker compose pull postgres redis`
    
3. **Launch the integrated demo**
    
    `./scripts/playthrough.sh`
    
    What happens automatically:
    
    - docker compose up -d postgres redis
    - PG health waits until pg_isready succeeds
    - Backend npm install, npm run db:migrate, npm run db:seed, npm run start:dev (port 3000)
    - Frontend npm install, npm run dev -- --port 3100 with NEXT_PUBLIC_API_URL=http://localhost:3000/api
    
    Frontend stays attached in the terminal; hit Ctrl+C when you’re done. Docker services stop unless you set KEEP_SERVICES=true.
    
4. **Optional confidence checks (new shell)**
    
    `curl http://localhost:3000/api/health cd frontend && NEXT_PUBLIC_API_URL=http://localhost:3000/api npm run smoke cd backend && npm run test && npm run test:e2e`
    
5. **Clean up after the demo**
    
    `docker compose down`
    

**Deep-Dive Checklist**

- ☐ **Environment ready**
    
    - Confirm Node ≥18, npm ≥9.
    - Docker Desktop running and docker info succeeds.
    - Ports 3000 (backend) and 3100 (frontend) free before starting.
- ☐ **Playthrough script completes**
    
    - Console shows “Waiting for Postgres to accept connections” followed by “Nest application successfully started” and 🚀 NCS Backend API running on http://localhost:3000/api.
    - Frontend terminal shows “Next.js … Ready” on [http://localhost:3100](http://localhost:3100/).
- ☐ **Frontend demo ([http://localhost:3100](http://localhost:3100/))**
    
    1. Navigate to “Authenticate”.
    2. Log in with admin@ncs.co.th / admin123.
        - Expected: status line reports token expiry, JSON response preview shows access/refresh tokens.
    3. Catalog list displays seeded products (“SW-24P-1G”, “RT-ENT-5G”, etc.).
    4. Add to cart, adjust quantities, clear cart—all reflect totals with VAT.
- ☐ **Admin/API smoke (curl or Postman)**
    
    1. Login (reuse token for the steps below):
        
        `TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login \ -H "Content-Type: application/json" \ -d '{"email":"admin@ncs.co.th","password":"admin123"}' | jq -r .accessToken)`
        
    2. Overview metrics:
        
        `curl http://localhost:3000/api/admin/overview -H "Authorization: Bearer $TOKEN"`
        
    3. Company tier update:
        
        `curl -X PUT http://localhost:3000/api/admin/companies/test-company-id/tier \ -H "Authorization: Bearer $TOKEN" \ -H "Content-Type: application/json" \ -d '{"tier":"PLATINUM"}'`
        
    4. Cart bulk import (buyer context):
        
        `printf 'productId,quantity\nsw-24p-1g-id,2\nrt-ent-5g-id,1\n' > /tmp/cart.csv curl -X POST http://localhost:3000/api/cart/bulk-import \ -H "Authorization: Bearer $TOKEN" \ -F file=@/tmp/cart.csv`
        
    5. Verify cart contents:
        
        `curl http://localhost:3000/api/cart -H "Authorization: Bearer $TOKEN"`
        
    6. Inventory search:
        
        `curl "http://localhost:3000/api/admin/products?search=SW" \ -H "Authorization: Bearer $TOKEN"`
        
- ☐ **Why it works**
    
    - Prisma migrations seed the catalog, companies, and users exactly as documented in the Technical Design (see backend/prisma/seed.ts).
    - Routes and guards align with the Execution Plan’s requirements: global /api prefix, JWT auth, and role checks around admin surfaces.
    - Frontend reads NEXT_PUBLIC_API_URL for every API call, so changing ports/env is centralized.
    - Playthrough script detects Postgres readiness before hitting Prisma, eliminating the P1001 errors we saw earlier.
- ☐ **If anything fails**
    
    - Backend health check fails → inspect backend terminal; restart ./scripts/playthrough.sh.
    - Frontend 404 on /api/products → ensure backend still running on port 3000; rerun curl health check.
    - CSV import error → verify file format (headers productId,quantity) and product IDs from seed file.
- ☐ **After demo**
    
    - Stop frontend with Ctrl+C.
    - Script cleanly shuts down backend and Docker. If you need the data for another session, leave services running via KEEP_SERVICES=true.

Follow this checklist each time, and the backend/frontend will stay in sync with the architecture outlined in the context docs.