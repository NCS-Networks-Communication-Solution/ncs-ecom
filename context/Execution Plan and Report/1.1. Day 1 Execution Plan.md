# NCS B2B E-Commerce Platform - Day 1 Execution Plan

## 1. Executive Summary

The NCS B2B E-Commerce platform modernizes Thailand's networking equipment procurement for SMEs and reseller partners through a mobile-first PWA. Core business goals include capturing SME market share, reducing manual quote/order overhead by ≥50% within 12 months, and achieving ≥30% online revenue within 24 months. The platform delivers a bilingual (Thai/English) self-service portal with real-time SAP-integrated pricing/inventory, streamlined RFQ→Quote→Order workflows, and Thai-compliant payment processing (PromptPay QR, e-wallets, tax invoices). Built as a modular monolith using NestJS/Next.js deployed on Docker Compose (development) with eventual Proxmox VE production deployment, the system targets <500ms API response times and 99.5% uptime. Day 0 successfully established the development environment, GitHub repository with governance, CI/CD pipeline, and initial project scaffolding. Day 1 focuses on containerization setup, database initialization, and backend API foundation to maintain the aggressive 115-day timeline toward the January 11, 2026 launch.

## 2. Architecture Snapshot

The platform implements an API-first modular monolith architecture with NestJS backend modules (CatalogModule, OrderModule, QuoteModule, PaymentModule) communicating via type-safe interfaces and in-memory event bus. The system separates into distinct layers:

• **Frontend**: Next.js PWA with SSR/SSG, offline caching, Thai/English i18n • **API Gateway**: NestJS with JWT auth, rate limiting, request validation • **Business Logic**: Domain-aligned modules with clear boundaries for future microservice extraction • **Data Layer**: PostgreSQL (transactional data), Redis (cache + BullMQ message queue) • **Integrations**: SAP ERP (via middleware/iPaaS), Omise payment gateway, Cloudflare CDN/WAF • **Infrastructure**: Docker Compose (dev), targeting Proxmox VE cluster (production) with LXC containers

## 3. Requirements & Acceptance

|REQ-ID|Description|Acceptance Test|
|---|---|---|
|REQ-001|Bilingual Mobile-First UI|Thai/English toggle works; offline caching functional; PWA installable|
|REQ-002|Multi-Tenant Company Accounts|Admin can invite users; shared company data visible only within company|
|REQ-003|Tiered Pricing & Discounts|Partner sees contract pricing; volume discounts apply correctly|
|REQ-004|Dynamic Product Catalog|Company-specific products shown; real-time SAP stock visible|
|REQ-005|Advanced Search & Filtering|SKU/spec search works; faceted filters narrow results correctly|
|REQ-006|RFQ Workflow|User submits RFQ; admin responds; quote converts to order|
|REQ-007|Partner Quote Generation|PDF quote with logo, pricing, validity date downloadable|
|REQ-008|Shopping Cart & Checkout|Persistent cart; CSV bulk-add; multi-step wizard with PO field|
|REQ-009|PromptPay QR Payment|QR displays; webhook updates order status to Paid|
|REQ-010|Bank Transfer & Slip Upload|Upload receipt; admin verifies; order marked Paid|
|REQ-011|Thai Tax Invoice PDF|Auto-generated with TIN, sequential number, VAT breakdown|
|REQ-012|Order & Fulfillment|Status updates (Pending→Shipped); SAP sync with retry|
|REQ-013|SAP ERP Integration|Inventory sync; order push with queue/retry/batch fallback|
|REQ-014|RBAC Roles|Admin/Purchaser/Viewer permissions enforced|
|REQ-015|Audit Logging|Critical actions logged with user, timestamp, changes|

## 4. Day 1 Plan

### Schedule (09:00-18:00 Bangkok Time)

- 09:00-10:30: Docker Compose setup & network configuration
- 10:30-12:00: Database initialization & migrations
- 13:00-14:30: Backend NestJS modules scaffolding
- 14:30-16:00: API endpoints & basic auth
- 16:00-17:30: Testing & CI integration
- 17:30-18:00: Documentation & commit

### Steps with Commands

#### Step 1: Docker Compose Setup (09:00-10:30)

```bash
# Navigate to project root
cd ~/ncs-ecom

# Create Docker Compose configuration
cat > docker-compose.yml << 'EOF'
version: '3.8'
services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: ncsdb
      POSTGRES_USER: ncsadmin
      POSTGRES_PASSWORD: ${DB_PASSWORD:-defaultpass}
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ncsadmin"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redisdata:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  pgdata:
  redisdata:
EOF

# Create environment file
cat > .env << 'EOF'
NODE_ENV=development
DB_PASSWORD=ncs2025secure
DATABASE_URL=postgresql://ncsadmin:ncs2025secure@localhost:5432/ncsdb
REDIS_URL=redis://localhost:6379
JWT_SECRET=ncs-jwt-secret-dev-2025
EOF

# Start services
docker-compose up -d

# Verify services
docker-compose ps
docker exec -it ncs-ecom-postgres-1 psql -U ncsadmin -d ncsdb -c '\l'
docker exec -it ncs-ecom-redis-1 redis-cli ping
```

**Acceptance**: Both containers running; `psql` lists ncsdb; redis returns PONG **Rollback**: `docker-compose down -v && rm docker-compose.yml .env`

### **Executive Summary**

The planned setup of the Docker Compose environment was **completed successfully**, with all services deployed and verified according to the acceptance criteria.

---

## Analysis Report

- **Objective:** To deploy a PostgreSQL database and a Redis cache as containerized services for a local development environment.
    
- **Execution Analysis:** The plan was followed precisely for the creation of the `docker-compose.yml` and `.env` configuration files. A minor, necessary deviation was made during execution: the modern `docker compose` command (with a space) was used instead of the legacy `docker-compose` (with a hyphen) specified in the plan. This change reflects current Docker standards and was essential for the commands to run.
    
- **Outcome: Success** The task fully met its defined acceptance criteria:
    
    1. **Containers Running:** The `docker compose ps` command confirmed that both `ncs-ecom-postgres-1` and `ncs-ecom-redis-1` containers are `Up` and `(healthy)`.
        
    2. **Postgres Verified:** The `psql` execution successfully connected to the database and listed the created `ncsdb`.
        
    3. **Redis Verified:** The `redis-cli` command received the expected `PONG` response, confirming the cache is operational.
        
- **Final Status:** The development environment is fully provisioned and ready for application connection.
#### Step 2: Database Schema & Migrations (10:30-12:00)

```bash
# Install Prisma
cd backend
npm install prisma @prisma/client
npx prisma init

# Configure Prisma schema
cat > prisma/schema.prisma << 'EOF'
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Company {
  id        String   @id @default(uuid())
  name      String   @unique
  taxId     String?  @unique @map("tax_id")
  tier      String   @default("STANDARD")
  users     User[]
  orders    Order[]
  quotes    Quote[]
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  @@map("companies")
}

model User {
  id         String   @id @default(uuid())
  email      String   @unique
  password   String
  name       String
  role       Role     @default(PURCHASER)
  companyId  String   @map("company_id")
  company    Company  @relation(fields: [companyId], references: [id])
  orders     Order[]
  quotes     Quote[]
  auditLogs  AuditLog[]
  createdAt  DateTime @default(now()) @map("created_at")
  
  @@map("users")
}

enum Role {
  ADMIN
  PURCHASER
  VIEWER
  SALES
}

model Product {
  id          String   @id @default(uuid())
  sku         String   @unique
  nameEn      String   @map("name_en")
  nameTh      String   @map("name_th")
  description String?
  price       Decimal  @db.Decimal(12, 2)
  stock       Int      @default(0)
  createdAt   DateTime @default(now()) @map("created_at")
  
  @@map("products")
}

model Quote {
  id        String      @id @default(uuid())
  companyId String      @map("company_id")
  company   Company     @relation(fields: [companyId], references: [id])
  userId    String      @map("user_id")
  user      User        @relation(fields: [userId], references: [id])
  status    QuoteStatus @default(PENDING)
  total     Decimal?    @db.Decimal(12, 2)
  items     Json
  order     Order?
  createdAt DateTime    @default(now()) @map("created_at")
  
  @@map("quotes")
}

enum QuoteStatus {
  PENDING
  SENT
  ACCEPTED
  REJECTED
}

model Order {
  id        String      @id @default(uuid())
  orderNo   String      @unique @map("order_no")
  companyId String      @map("company_id")
  company   Company     @relation(fields: [companyId], references: [id])
  userId    String      @map("user_id")
  user      User        @relation(fields: [userId], references: [id])
  quoteId   String?     @unique @map("quote_id")
  quote     Quote?      @relation(fields: [quoteId], references: [id])
  status    OrderStatus @default(PENDING)
  total     Decimal     @db.Decimal(12, 2)
  items     Json
  poNumber  String?     @map("po_number")
  createdAt DateTime    @default(now()) @map("created_at")
  
  @@map("orders")
}

enum OrderStatus {
  PENDING
  PAID
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id])
  action    String
  entity    String
  entityId  String   @map("entity_id")
  changes   Json?
  createdAt DateTime @default(now()) @map("created_at")
  
  @@map("audit_logs")
}
EOF

# Run migrations
npx prisma migrate dev --name init

# Seed initial data
cat > prisma/seed.ts << 'EOF'
import { PrismaClient } from '@prisma/client';
import * as bcrypt from 'bcrypt';

const prisma = new PrismaClient();

async function main() {
  const hashedPassword = await bcrypt.hash('admin123', 10);
  
  const company = await prisma.company.create({
    data: {
      name: 'NCS Networks',
      taxId: '0105558000000',
      tier: 'ADMIN',
      users: {
        create: {
          email: 'admin@ncs.co.th',
          password: hashedPassword,
          name: 'System Admin',
          role: 'ADMIN'
        }
      }
    }
  });
  
  await prisma.product.createMany({
    data: [
      {
        sku: 'SW-24P-1G',
        nameEn: '24-Port Gigabit Switch',
        nameTh: 'สวิตช์ 24 พอร์ต กิกะบิต',
        price: 15000,
        stock: 10
      },
      {
        sku: 'RT-AC-5G',
        nameEn: 'AC WiFi Router 5GHz',
        nameTh: 'เราเตอร์ไวไฟ AC 5GHz',
        price: 8500,
        stock: 25
      }
    ]
  });
}

main()
  .catch(console.error)
  .finally(() => prisma.$disconnect());
EOF

# Update package.json for seeding
npm install --save-dev @types/bcrypt bcrypt ts-node

# Run seed
npx ts-node prisma/seed.ts
```

**Acceptance**: Migration applied; tables created; seed data inserted **Rollback**: `npx prisma migrate reset --force`

#### Step 3: NestJS Modules Setup (13:00-14:30)

```bash
# Generate core modules
npx nest g module auth
npx nest g module catalog
npx nest g module orders
npx nest g module quotes

# Create auth service
cat > src/auth/auth.service.ts << 'EOF'
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../prisma/prisma.service';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService
  ) {}

  async login(email: string, password: string) {
    const user = await this.prisma.user.findUnique({
      where: { email },
      include: { company: true }
    });

    if (!user || !await bcrypt.compare(password, user.password)) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const payload = {
      sub: user.id,
      email: user.email,
      role: user.role,
      companyId: user.companyId
    };

    return {
      access_token: this.jwtService.sign(payload),
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        role: user.role,
        company: user.company.name
      }
    };
  }
}
EOF

# Create Prisma service
npx nest g module prisma
cat > src/prisma/prisma.service.ts << 'EOF'
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }
}
EOF

# Install dependencies
npm install @nestjs/jwt @nestjs/passport passport passport-jwt
```

**Acceptance**: Modules created in src/; services compile without error **Rollback**: `git clean -fd src/`

#### Step 4: API Endpoints (14:30-16:00)

```bash
# Create auth controller
cat > src/auth/auth.controller.ts << 'EOF'
import { Controller, Post, Body } from '@nestjs/common';
import { AuthService } from './auth.service';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('login')
  async login(@Body() dto: { email: string; password: string }) {
    return this.authService.login(dto.email, dto.password);
  }
}
EOF

# Create catalog controller
cat > src/catalog/catalog.controller.ts << 'EOF'
import { Controller, Get, Query } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Controller('products')
export class CatalogController {
  constructor(private prisma: PrismaService) {}

  @Get()
  async findAll(@Query('search') search?: string) {
    const where = search ? {
      OR: [
        { nameEn: { contains: search, mode: 'insensitive' } },
        { nameTh: { contains: search, mode: 'insensitive' } },
        { sku: { contains: search, mode: 'insensitive' } }
      ]
    } : {};

    return this.prisma.product.findMany({ where });
  }
}
EOF

# Test the API
npm run start:dev &
sleep 5

# Test endpoints
curl -X POST http://localhost:3000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@ncs.co.th","password":"admin123"}'

curl http://localhost:3000/products
```

**Acceptance**: Login returns JWT token; Products endpoint returns 2 items **Rollback**: Kill the dev server process

#### Step 5: Testing & CI (16:00-17:30)

```bash
# Add test for auth
cat > src/auth/auth.service.spec.ts << 'EOF'
import { Test } from '@nestjs/testing';
import { AuthService } from './auth.service';

describe('AuthService', () => {
  let service: AuthService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [AuthService],
    }).compile();

    service = module.get<AuthService>(AuthService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
EOF

# Update GitHub Actions workflow
cat >> .github/workflows/ci.yml << 'EOF'

  backend-integration:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      - name: Test Backend
        run: |
          cd backend
          npm ci
          npx prisma migrate deploy
          npm run test
EOF

# Run tests locally
npm test
```

**Acceptance**: Tests pass; CI workflow updated **Rollback**: Revert CI changes if tests fail

#### Step 6: Documentation & Commit (17:30-18:00)

```bash
# Update backend README
cat > backend/README.md << 'EOF'
# NCS B2B E-Commerce Backend

## Setup
1. Install dependencies: `npm install`
2. Setup database: `npx prisma migrate dev`
3. Seed data: `npx prisma db seed`
4. Start dev server: `npm run start:dev`

## Environment Variables
- DATABASE_URL: PostgreSQL connection string
- REDIS_URL: Redis connection string
- JWT_SECRET: Secret for JWT signing

## API Endpoints
- POST /auth/login - User authentication
- GET /products - List products (with search)
EOF

# Commit all changes
git add .
git commit -m "feat: implement backend foundation with auth and catalog modules

- Set up Docker Compose for PostgreSQL and Redis
- Initialize Prisma schema with core models
- Implement JWT authentication
- Create catalog API with search
- Add initial seed data
- Configure CI/CD integration tests"

git push origin main
```

**Acceptance**: README created; changes committed and pushed **Rollback**: `git reset --soft HEAD~1` if commit issues

### EOD Artifacts Checklist

- [ ] Docker Compose running PostgreSQL + Redis
- [ ] Database schema migrated with core tables
- [ ] NestJS backend with auth/catalog modules
- [ ] JWT authentication working
- [ ] Product search API functional
- [ ] Initial seed data loaded
- [ ] Tests passing
- [ ] CI workflow updated
- [ ] Documentation updated
- [ ] Code committed to main branch

## 5. Risk & Dependency Log

### Risks

|Risk|Impact|Mitigation|
|---|---|---|
|Docker resource consumption on dev machine|High|Monitor with `docker stats`; adjust memory limits|
|Database migration conflicts|Medium|Always backup before migration; use explicit migration names|
|JWT secret exposure|High|Use .env files; never commit secrets|
|API performance with full catalog|Medium|Implement pagination early; add Redis caching|

### Dependencies

|Dependency|Owner|Status|
|---|---|---|
|PostgreSQL 15|Docker Hub|Available|
|Redis 7|Docker Hub|Available|
|Omise API sandbox|Payment team|Need credentials by Day 10|
|SAP test endpoint|ERP team|Need by Day 15|

### Decisions

|Decision|Rationale|Alternative Considered|
|---|---|---|
|Use Prisma ORM|Type-safety, migrations, good DX|TypeORM - more mature but verbose|
|UUID primary keys|Security, no enumeration attacks|Auto-increment - simpler but less secure|
|Docker Compose for dev|Consistent environments, easy cleanup|Local installs - faster but inconsistent|
|JWT for auth|Stateless, scalable|Sessions - simpler but needs sticky sessions|

## 6. Next-Day Planner Mini-Prompt

```markdown
You are a technical execution assistant. Read all provided documents and generate Day [N] execution plan.

INPUTS:
- All project documents (Technical Design, Blueprint, Month 1 Plan)
- Previous day's completion status and artifacts
- Current date: [DATE] (Asia/Bangkok)
- Completed items from backlog

GENERATE:
1. Day [N] Schedule (09:00-18:00 BKK)
   - Time blocks with specific tasks
   - Dependencies from previous days

2. Executable Steps
   For each task:
   - Exact CLI commands (macOS/Linux compatible)
   - File contents to create/modify
   - Environment variables needed
   - Acceptance criteria (measurable)
   - Rollback procedure if step fails

3. Progress Tracking
   - Update REQ-ID completion status
   - List completed user stories
   - Remaining items for week/sprint

4. Risk Assessment
   - New risks identified
   - Blocked items needing attention
   - Dependencies for next day

5. Commit Structure
   - Conventional commit messages
   - Branch strategy if not on main
   - PR description if applicable

CONSTRAINTS:
- Align with Month 1 plan milestones
- Maintain modular monolith architecture
- PostgreSQL + Redis + BullMQ stack
- Thai business context (PromptPay, tax invoices)
- No scope creep beyond defined REQs

OUTPUT FORMAT:
- Markdown with clear headers
- Runnable code blocks
- Tables for structured data
- Checklist for EOD verification

Current backlog status:
- [x] REQ-XXX: Environment setup
- [ ] REQ-001: Bilingual UI (Day 3-4)
- [ ] REQ-002: Multi-tenant accounts (Day 2)
...
```

---

**Tomorrow's Focus**: Day 2 will implement multi-tenant company accounts (REQ-002), user invitation system, and basic RBAC foundation per the Month 1 plan's Week 1 objectives.