{"file":"/Users/pkaewmanee/Desktop/Project_Hiroshima/ncs-ecom/backend/src/auth/auth.service.ts","mappings":"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","names":[],"sources":["/Users/pkaewmanee/Desktop/Project_Hiroshima/ncs-ecom/backend/src/auth/auth.service.ts"],"sourcesContent":["import { BadRequestException, ConflictException, Injectable, UnauthorizedException } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from '../prisma.service';\nimport * as bcrypt from 'bcryptjs';\nimport { randomUUID } from 'crypto';\nimport { RegisterDto } from './dto/register.dto';\nimport { LoginDto } from './dto/login.dto';\nimport { AuthResponse } from './dto/auth-response.dto';\nimport { AdminCompanySummary, AdminRole, AdminUser } from '../types/admin.types';\nimport { Prisma } from '@prisma/client';\n\ninterface UserWithCompany {\n  id: string;\n  email: string;\n  password: string;\n  name: string;\n  role: AdminRole;\n  companyId: string;\n  isActive?: boolean | null;\n  companies: AdminCompanySummary | null;\n}\n\n@Injectable()\nexport class AuthService {\n  private static readonly ACCESS_TOKEN_TTL_SECONDS = 60 * 60 * 24; // 24 hours\n  private static readonly REFRESH_TOKEN_TTL_SECONDS = 60 * 60 * 24 * 7; // 7 days\n\n  constructor(\n    private prisma: PrismaService,\n    private jwtService: JwtService\n  ) {}\n\n  async register(dto: RegisterDto): Promise<AuthResponse> {\n    try {\n      const existingUser = await this.prisma.users.findUnique({ where: { email: dto.email } });\n      if (existingUser) {\n        throw new ConflictException('Email address is already registered');\n      }\n\n      const company = await this.prisma.companies.findUnique({ where: { id: dto.companyId } });\n      if (!company) {\n        throw new BadRequestException('Invalid company ID');\n      }\n\n      const hashedPassword = await bcrypt.hash(dto.password, 10);\n\n      const createdUser = await this.prisma.users.create({\n        data: {\n          id: randomUUID(),\n          email: dto.email,\n          password: hashedPassword,\n          name: dto.name,\n          role: 'USER',\n          companies: {\n            connect: { id: dto.companyId },\n          },\n        },\n      });\n\n      const user = await this.findUserWithCompany(createdUser.id);\n\n      if (!user) {\n        throw new UnauthorizedException('Unable to load created user');\n      }\n\n      return this.generateTokens(user);\n    } catch (error) {\n      if (\n        error instanceof ConflictException ||\n        error instanceof BadRequestException ||\n        error instanceof UnauthorizedException\n      ) {\n        throw error;\n      }\n\n      if (error instanceof Prisma.PrismaClientKnownRequestError) {\n        if (error.code === 'P2002') {\n          const target = error.meta?.target as string[] | undefined;\n          if (target?.includes('email')) {\n            throw new ConflictException('Email address is already registered');\n          }\n          throw new ConflictException('Registration failed due to duplicate data');\n        }\n\n        if (error.code === 'P2025') {\n          throw new BadRequestException('Invalid company ID');\n        }\n      }\n\n      if (error instanceof Prisma.PrismaClientInitializationError) {\n        throw new BadRequestException('Database connection failed');\n      }\n\n      console.error('Unexpected registration error:', error);\n      throw new BadRequestException('Registration failed due to an unexpected error');\n    }\n  }\n\n  async login(dto: LoginDto): Promise<AuthResponse> {\n    const user = await this.prisma.users.findUnique({\n      where: { email: dto.email },\n      include: { companies: true },\n    });\n\n    if (!user || !(await bcrypt.compare(dto.password, user.password))) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    if (user.isActive === false) {\n      throw new UnauthorizedException('Account is deactivated');\n    }\n\n    return this.generateTokens(user as UserWithCompany);\n  }\n\n  async refreshToken(refreshToken: string): Promise<AuthResponse> {\n    if (!refreshToken) {\n      throw new UnauthorizedException('Refresh token required');\n    }\n\n    let payload: any;\n    try {\n      payload = this.jwtService.verify(refreshToken);\n    } catch (error) {\n      throw new UnauthorizedException('Invalid refresh token');\n    }\n\n    if (!payload?.sub || payload.type !== 'refresh') {\n      throw new UnauthorizedException('Invalid refresh token');\n    }\n\n    const storedToken = await this.prisma.refresh_tokens.findFirst({\n      where: {\n        userId: payload.sub,\n        expiresAt: { gt: new Date() },\n      },\n    });\n\n    if (!storedToken) {\n      throw new UnauthorizedException('Refresh token expired or not found');\n    }\n\n    const isValid = await bcrypt.compare(refreshToken, storedToken.tokenHash);\n    if (!isValid) {\n      throw new UnauthorizedException('Invalid refresh token');\n    }\n\n    const user = await this.findUserWithCompany(payload.sub);\n    if (!user) {\n      throw new UnauthorizedException('User not found');\n    }\n\n    if (user.isActive === false) {\n      throw new UnauthorizedException('Account is deactivated');\n    }\n\n    return this.generateTokens(user as UserWithCompany);\n  }\n\n  private async generateTokens(user: UserWithCompany): Promise<AuthResponse> {\n\n    const payload = {\n      sub: user.id,\n      email: user.email,\n      role: user.role,\n      companyId: user.companyId,\n    };\n\n    const accessToken = this.jwtService.sign(payload, {\n      expiresIn: AuthService.ACCESS_TOKEN_TTL_SECONDS,\n    });\n\n    const { refreshToken } = await this.saveRefreshToken(user.id);\n\n    return {\n      accessToken,\n      refreshToken,\n      expiresIn: AuthService.ACCESS_TOKEN_TTL_SECONDS,\n      user: this.mapToAdminUser(user),\n    };\n  }\n\n  private async saveRefreshToken(userId: string) {\n    await this.prisma.refresh_tokens.deleteMany({ where: { userId } });\n\n    const refreshToken = this.jwtService.sign(\n      { sub: userId, type: 'refresh' },\n      { expiresIn: AuthService.REFRESH_TOKEN_TTL_SECONDS }\n    );\n\n    const tokenHash = await bcrypt.hash(refreshToken, 10);\n    const expiresAt = new Date(Date.now() + AuthService.REFRESH_TOKEN_TTL_SECONDS * 1000);\n\n    await this.prisma.refresh_tokens.create({\n      data: {\n        id: randomUUID(),\n        userId,\n        tokenHash,\n        expiresAt,\n      },\n    });\n\n    return { refreshToken, expiresAt };\n  }\n\n  private findUserWithCompany(userId: string) {\n    return this.prisma.users.findUnique({\n      where: { id: userId },\n      include: { companies: true },\n    });\n  }\n\n  private mapToAdminUser(user: UserWithCompany): AdminUser {\n    return {\n      id: user.id,\n      name: user.name,\n      email: user.email,\n      role: user.role,\n      company: user.companies\n        ? {\n            id: user.companies.id,\n            name: user.companies.name,\n            tier: user.companies.tier,\n          }\n        : null,\n    };\n  }\n}\n"],"version":3}